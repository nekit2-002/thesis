#import "../biblio.typ":*
#show bibliography: none
// TODO this import is here only for lsp, need to remove it on release
// #bibl
// -------------------------------------------------------------------------------







= Анализ устройства и использования памяти СУБД PostgreSQL

== Анализ общего устройства PostgreSQL
Чтобы проанализировать общее устройство СУБД PostgreSQL, рассмотрим принципы взаимодействия пользователя
с системой, алгоритмы и модели, используемые системой для выдачи результатов по запросам пользователя.
PostgreSQL использует реляционную модель данных @rel, что означает, что каждый объект в ней
рассматривается как отношение и подчиняется законам реляционной алгебры. С точки зрения архитектуры
PostgreSQL основывается на клиент--серверном взаимодействии @client-server. Данный раздел посвящен
анализу архитектуры сервера Postgres, а также разбору методов работы сервера с физической памятью устройства.




=== Клиент--серверное взаимодействие и принципы ACID
Глобально система делится на две части: клиентское приложение и сервер Postgres. Приложение может с использованием
протокола взаимодействия PostgreSQL Protocol (основан на TCP/IP) подключаться к базам данных и взаимодействовать
с объектами в них. Для того чтобы не писать собственную реализацию протокола для каждого клиентского приложения,
Postgres предоставляет библиотеку libpq @libpq, порты которой на всевозможные языки программирования
обычно и являются драйверами для соединения пользовательского приложения с сервером PostgreSQL.

После успешной аутентификации и подключения к базе данных пользователь может посылать к ней запросы.
Каждый запрос выполняется в рамках транзакции (см. @fig:client), представляющей собой некоторый набор
логически связанных операций, которые мыслятся как единое целое. Каждая транзакция подчиняется подчиняется
четырем свойствам АСИД (они же ACID @acid):
+ Атомарность --- транзакция либо выполняется целиком, либо не выполняется вообще
+ Согласованность --- в начале транзакции она должна видеть согласованную целостную
  картину данных и оставить согласованную картину данных после себя 
+ Изолированность --- обеспечение определенности во влиянии параллельных процессов друг на друга
+ Долговечность --- если транзакция зафиксирована, ее изменения не должны быть утеряны (даже при сбое)

#figure(
  image("../images/analysis/client-server.png", width: 70%),
  caption: [Схема транзакционного взаимодействия клиента и сервера]
) <fig:client>

Рассмотрим теперь процедуру обработки запроса (см. @fig:query). На первом этапе происходит
синтаксический анализ (проверка отсутствия ошибок в коде написанного запроса),
в результате которого получается абстрактное синтаксическое дерево (АСД) запроса, и далее
семантический анализ, выполняющий привязку узлов АСД к реальным
объектам в базе данных, информация о которых берется из системного каталога данной
БД (системный каталог --- схема БД, описывающая все подробности об ее объектах и типах их
содержимого).

После получения дерева запроса наступает второй этап, на котором дерево трансформируется 
(переписывается) по некоторым правилам
(например, если в запросе содержится представление, то при переписывании оно раскрывается в
запрос, который тоже проходит этап 1 и дерево этого запроса интегрируется в дерево основного
запроса).

Когда получено окончательное дерево, включающее весь запрос, начинается этап планирования, на котором планировщик запросов перебирает различные варианты исполнения запроса,
оценивает каждый из них, и, найдя оптимальный, передает дерево плана на исполнение.

Далее запрос исполняется и результат возвращается пользователю. При исполнении запроса происходит обход дерева плана, и для каждого узла, если для него еще нет данных,
которые ему нужно получить, он спускается по узлам ниже, пока не дойдет до "листового". Когда дочерних узлов нет, происходит непосредственное получение данных из
таблицы с помощью _метода доступа_, после чего прочитанные данные передаются узлам выше, пока запрос не будет исполнен.

#figure(
  image("../images/analysis/query.png", width: 70%),
  caption: [Этапы обработки запроса]
) <fig:query>




=== Взаимодействие PostgreSQL с памятью устройства
Чтобы понять, каким образом Postgres взаимодействует с памятью устройства, на котором запущен 
сервер, рассмотрим устройство работы сервера
с точки зрения процессов. Главным процессом на сервере является Postgres (он же postmaster), и 
его задача состоит в том, чтобы запустить все другие процессы.
Он же создает общую память (см. @fig:memory), чтобы процессы могли обмениваться данными между собой, следит за сбоями в дочерних процессах, чтобы при
перезапускать их.

Когда появляется клиент, подключающийся к Postgres, его сначала принимает postmaster, после чего 
создается обслуживающий backend процесс, и postmaster
переключает клиента на работу с этом backend--процессом. Каждый backend имеет локальную память, 
в которой сохраняется вся информация, нужная конкретному клиенту, например, разобранные запросы.

#figure(
  image("../images/analysis/memory.png", width: 50%),
  caption: [Схема общего механизма обращения с памятью в PostgreSQL]
) <fig:memory>

Непосредственно работа с файлами на дисках не осуществляется сервером напрямую, для этого 
используется буферный кеш,
находящийся в общей памяти сервера. Буферный кеш представляет собой массив буферов, каждый из 
которых хранит в себе
*страницу* данных --- единицу обмена информацией между Postgres и операционной системой, и также
дополнительную информацию (например, имя файла и положение страницы внутри этого файла).

Если какой--либо процесс собирается работать со страницей, он в первую очередь пытается найти ее 
в кеше. Если страницы нет,
он обращается к операционной системе с просьбой прочитать эту 
страницу и помещает ее в буферный кеш (доступ к данным при этом может оказаться достаточно 
быстрым, если нужная страница найдена
в кеше операционной системы и обращения к диску не произойдет). Если в кеше оперативной памяти 
нужная страница не найдена,
происходит двойная буферизация: сначала ОС копирует данные в собственный кеш, затем они попадают 
в буферный кеш сервера.

Если процесс изменил данные в странице, соответствующий буфер становится "грязным". Измененная 
страница подлежит записи на диск, 
но по соображениям производительности запись происходит асинхронно и может откладываться. При 
совместном доступе
процессов к одному и тому же месту в буферном кеше делаются блокировки для предотвращения 
состояния гонки.

Размер буферного кеша обычно не так велик, чтобы база данных помещалась в него целиком, и в 
таких ситуациях
имеет место алгоритм вытеснения страниц, который выбирает в кеше страницу, которая в последнее 
время использовалась реже других. Если выбранный буфер оказался  грязным, страница записывается
на диск, чтобы не потерять сделанные  в ней изменения. Затем в освободившийся буфер читается 
новая страница (алгоритм вытеснения LRU @lru).




== Исследование механизмов многоверсионности и очистки страниц
При при параллельной работе нескольких транзакций могут быть ситуации (например, при 
одновременной записи в одну и ту же строку таблицы), когда помимо блокировки нет вариантов 
разрешения состояния гонки. Тем не менее, если применять такой же подход в других случаях (в 
частности, когда одна из двух транзакций пишет данные, а другая читает), возникнет проблема,
что если транзакций много, и все они будут вынуждены выстраиваться в очередь на выполнение из-за 
блокировок, производительность системы сильно упадет.



=== Многоверсионность и снимки <snaps>
Чтобы оптимизировать выполнение параллельных запросов, в Postgres используется механизм 
многоверсионности MVCC @mvcc1 @mvcc2, который подразумевает одновременное существование в базе 
данных нескольких версий одних и тех же версий строк. При этом читающая транзакция работает со 
своей версией, а пишущая --- со своей. Рассмотрим механизм работы с разными версиями строк.

#figure(
  image("../images/analysis/snapshot1.png", width: 50%),
  caption: [Схема общего механизма обращения с памятью в PostgreSQL]
) <fig:snapshot1>

На @fig:snapshot1 показана растянутая во времени конфигурация некоторой таблицы. В 
системе в качестве единицы временного отсчета выступают номера транзакций $x_id$. Время 
существования каждой строки определяется номерами создавшей и удалившей строку транзакций. 
Обновление строки при этом воспринимается как прекращение существования старой версии строки и 
начало существования новой.

Для того чтобы обеспечить согласованность данных для различных транзакций, применяются снимки 
данных. Очередная транзакция, обращаясь к таблице, должна видеть только одну из имеющихся версий 
каждой строки (или не видеть ни одной). Для этого транзакция работает со снимком данных, 
созданным в определенный  момент времени. На @fig:snapshot1 показана ситуация, в 
которой:
- У 1 строки существовала первая версия, но затем произошло зафиксированное обновление, и на 
  момент снимка будет видна уже вторая версия этой строки, при этом версия существует и после 
  снятия снимка, а значит она _актуальна_.
- Строка 2 на момент создания снимка уже была изменена, как и в первом случае, но после снятия
  снимка вторя версия строки сменилась на третью, которая в свою очередь была затем полностью 
  удалена, поэтому строка, попавшая в снимок будет _неактуальна_.
- Строка 3 имела всего одну версию, и поскольку удалившая ее транзакция была зафиксирована,
  и произошла раньше транзакции снятия снимка, в снимке эта строка не будет видна вообще

Сам снимок представляет из себя набор чисел следующего формата:
- $x_min$ --- номер самой ранней активной транзакции на момент снимка.
- $x_max$ --- номер следующей за номером последней зафиксированной транзакции, определяющий
    момент, когда был сделан снимок
- $x i p \_ l i s t$ --- список активных на момент снятия снимка транзакций

В снимке видны изменения транзакции $x_id$, которая удовлетворяет условиям:
- $x_id < x_min$ (поскольку все изменения таких транзакций уже были зафиксированы)
- $(x_min lt.eq.slant x_id < x_max) and x_id in.not x i p \_ l i s t$
  (чтобы отобрать изменения уже завершившихся транзакций)

В зависимости от того, в какой момент времени производится снимок, транзакция будет иметь разные 
уровни изоляции: для Read Commited снимок будет делаться на момент каждого запроса, а Repeatable 
Read и выше --- в начале транзакции, и снимок будет один на все операции внутри транзакции.




=== Компоновка страницы и автоочистка
Для того чтобы понять, каким образом в памяти хранятся различные версии строк, рассмотрим формат 
размещения данных на страницах, применяемый PostgreSQL. Согласно этому формату (см. @fig:page), 
главными составляющими табличной страницы являются следующие: заголовок страницы и блок 
указателей на версии строк, которые располагаются в начале страницы, и сами строки, каждая из 
которых состоит из, собственно, данных строки, и заголовка строки. В середине страницы 
располагается свободное пространство для вставки новых данных.

#figure(
  image("../images/analysis/page.png", width: 60%),
  caption: [Размещение данных в странице]
) <fig:page>

Размер страницы обычно составляет 8 КБ, но это значение можно изменить при сборке из исходного 
кода. Заголовок страницы занимает 24 байта (с выравниванием) и содержит общую информацию о ней, 
например, смещение до начала свободного пространства и специальной области, информация о размере
страницы, контрольная сумма страницы и проч.

Далее идет массив идентификаторов (указателей) строк. Каждый указатель занимает 4 байта и 
содержит информацию о смещении кортежа в строке, размере этого кортежа (оба параметра в байтах), 
и несколько битов, отвечающих за статус версии строки (например, normal или unused).

После свободного пространства идут данные о версиях строк. Версии строк в таблице заполняются с 
конца страницы. При вставке строк всегда по возможности происходит вставка на страницу строки 
целиком (если это невозможно, то строка либо сжимается, либо происходит перемещение ее части в 
TOAST--таблицу). В заголовке строки биты флагов отвечают за статусы создавшей и удалившей строку 
транзакций, а также за наличие строки в цепочке hot--обновлений. Также заголовок строки обычно 
содержит информацию о:
- номере транзакции, создавшей строку
- номере транзакции, прекратившей существование строки
- количестве атрибутов
- битах флагов всевозможных статусов и доп. информации
- отступе до пользовательских данных
- ссылке на следующую версию строки

Описанный способ организации данных представляет собой штатный табличный
_метод доступа_ к данным в PostgreSQL и обычно называется _Heap Access Method_.
 
Поскольку как актуальные, так и неактуальные версии строк содержатся в одном пространстве, со 
временем происходит активный расход памяти, приводящий к замедлению выполнения запросов при 
обращении к таблицам. Эта проблема в Postgres решается посредством запуска процесса регулярной 
очистки таблиц, называемого _vacuum_. У него есть две версии: обычная и глубокая.

Рассмотрим принцип работы обычной очистки. Для ускорения ее работы при первом запуске vacuum 
создается (а при последующих --- обновляется) _битовая карта видимости_ страниц. В ней каждой 
странице таблицы сопоставляется бит, говорящий о том, что в данной странице
все версии кортежей являются видимыми для всех пользователей. За счет использовании данной карты 
vacuum получает возможность при повторных запусках не читать таблицу полностью, а просматривать
только те страницы, где этот бит не установлен.

Последовательность действий очистки можно описать следующим образом:
- Vacuum читает таблицу и составляет список версий строк, которые можно вычистить. Он запоминает 
  идентификаторы этих строк и записывает их в части локальной памяти процесса равной значению 
  параметра maintenance_work_mem.
- Пользуясь сохраненными идентификаторами, vacuum выполняет очистку индексов таблицы, 
  просматривая каждый из них полностью.
- Используя те же идентификаторы, vacuum снова читает таблицу полностью, и при этом очищает ее 
  от сохраненных в maintenance_work_mem строк.

К описанным действиям следует сделать несколько *замечаний*. Первое: если количество 
неактуальных кортежей слишком велико чтобы поместиться в maintenance_work_mem, vacuum 
циклически выполняет описанные операции, что занимает дополнительное время и аппаратные ресурсы,
потому что объекты БД вынужденно перечитываются несколько раз. Второе: *физического 
перестроения* данных на уровне файлов системы *не происходит*,
а очищенные указатели просто помечаются vacuum как свободные для вставки, поэтому, если файл 
объекта увеличился в процессе работы, без _полной очистки_ меньше он не станет и место не 
вернется в распоряжение операционной системы.

Для того чтобы не запускать vacuum каждый раз вручную, на сервере Postgres есть постоянно 
работающий фоновый процесс, называемый _autovacuum launcher_. Принцип его работы следующий: при 
создании сервера в его настройках выставляется параметр _autovacuum_naptime_ (измеряется в 
секундах), и autovacuum launcher раз в autovacuum_naptime секунд обращается к процессу 
postmaster, чтобы тот запустил один или несколько (свой для каждой БД) рабочих процессов очистки
_autovacuum worker_, которые очищают таблицы БД.

Очищать таблицу или нет, autovacuum worker определяет по правилу:

$ N > "autovacuum_vacuum_threshold" + "autovacuum_vacuum_scale_factor" ast.op N_1 $
где:
- $N$ --- число ненужных строк в таблице
- _autovacuum_vacuum_threshold_ --- параметр, количество мертвых записей, которые должны 
  быть в таблице
- _autovacuum_vacuum_scale_factor_ --- параметр, некоторый процент, часть от общего числа 
  строк в таблице ($N_1$)

Тем не менее, ни vacuum, ни autovacuum worker не производят физической очистки памяти и 
возвращения ее ОС. Для этой задачи используется запуск процесса командой _VACUUM FULL_
(_полная очистка_). Она полностью блокирует доступ к таблице и на запись и на чтение, поскольку 
происходит физическое перестроение файлов в системе. Такая команда во время работы создает новые 
файлы в табличных пространствах и копирует в них данные из старых файлов наиболее компактным 
способом. Как и обычный vacuum, VACUUM FULL может занимать длительное время и требовать в 
процессе работы дополнительное место на диске для новых файлов, пока старые еще существуют.




== Анализ существующих решений поставленной задачи
Чтобы более отчетливо увидеть влияние autovacuum на производительность СУБД, сравним стандартный 
Heap Access Method и несколько проектов, реализовавших собственные методы доступа: zheap и 
orioledb. Первое расширение, ввиду давности его разработки, было встроено разработчиками
как часть ядра, в то время как второе подчиняется стандартной архитектуре расширения для 
PostgreSQL (описание дается в @arch).

Оба метода доступа используют для оптимизации концепцию undo--logging @undo1 @undo2 @undo3 
(более подробное объяснение алгоритма дается в @algo). При ее использовании требуется 
минимальное (или не требуется вообще) задействование autovacuum, а все изменения пишутся сразу 
на диск и старые версии строк не хранятся в таблицах, что приводит к тому, что они не распухают. 
Использование данной методики делает процесс оперирования таблицами более устойчивым в отношении 
скорости работы, поскольку даже при частых вызовах autovacuum не будет иметь работы для очистки, 
и потому не забирать системные ресурсы и задерживать выполнение запросов.





#pagebreak()
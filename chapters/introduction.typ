#import "../biblio.typ":*
#show bibliography: none
// TODO this import is here only for lsp, need to remove it on release
// #bibl
// -------------------------------------------------------------------------------







#set heading(numbering: none)
#show heading: set align(center)
= Введение
В настоящее время актуальной темой являются исследования @dbms4 @dbms5 @dbms3, связанные со всевозможными характеристиками 
реляционных систем управления базами данных @dbms6. Одной из наиболее популярных из них является СУБД PostgreSQL @dbms1 @dbms2.
В ее основе лежит клиент--серверная архитектура @client-server, и поскольку клиент, подключающийся к базе данных,
может быть не один, очень важно наличие механизма, осуществляющего параллельное взаимодействие с каждым из них.

Если несколько клиентов подключаются к одной и той же базе данных (БД), они могут оперировать параллельно одними и теми же
объектами. Для разрешения неопределенности в очередности исполнения операций с данными есть несколько механизмов.
Один из них, использующийся в PostgreSQL, называется MVCC @mvcc1 @mvcc2. Согласно ему, в базе данных могут содержаться несколько
версий одной и той же строки (многоверсионность), а все действия в системе происходят внутри транзакций, каждая из которых имеет свой идентификатор.
При работе с данными на текущей транзакции по определенным принципам производится снимок текущей картины данных, и процесс,
исполняющий запрос пользователя, работает с данными, актуальными на момент снимка.

При таком подходе к разрешению проблемы параллелизма возникает проблема, что при активном обновлении больших таблиц старых
версий строк (кортежей) становится слишком много, и необходимо время от времени производить очистку таблиц от неактуальных
версий строк. В PostgreSQL для решения этой задачи используется фоновый процесс очистки, называющийся vacuum @vac1 @vac2.
При его неправильном использовании производительность СУБД снижается.

В данной работе решается задача реализации более производительного хранилища данных для PostgreSQL
(под хранилищем будем понимать физическое размещение данных в памяти и алгоритмы доступа к этим данным),
которое позволило бы увеличить скорость исполнения запросов за счет сведения использования очистки к минимуму.

Для достижения описанной цели необходимо решить ряд следующих задач:




#pagebreak()
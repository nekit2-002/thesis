#import "../biblio.typ":*
#show bibliography: none
// TODO this import is here only for lsp, need to remove it on release
// #bibl
// -------------------------------------------------------------------------------







= Проектирование расширения для нового метода доступа к данным

== Архитектура расширения <arch>
PostgreSQL обладает определенным форматом архитектуры, которому должны подчиняться все разрабатываемые расширения на
языке С. Поскольку расширение разрабатывается с использованием инструментов Rust, его архитектура будет отличаться от
стандартной, но в нем будут присутствовать некоторые элементы, характерные для обычных расширений, поэтому далее
рассмотрим основные составляющие элементы стандартных расширений.

Стандартное расширение PostgreSQL обычно располагается в одном из его каталогов (contrib), и включает следующие
составные части:

- _extension.control_ --- файл управления расширением
- _extension.c_ --- исходный код расширения
- _Makefile/meson.build_ --- файл для сборки расширения в зависимости от сборочной системы
- _extension - -1.0.sql_ --- SQL--скрипт, создающий объекты БД, необходимые для работы расширения

В .control файле содержатся несколько обязательных строк, которые необходимы для работы расширения:

- _default_version_ --- параметр, указывающий какая версия скрипта загружается по умолчанию
- _module_pathname_ --- путь к исполняемому файлу собранного расширения
- _relocatable_ --- флаг, говорящий о том, что все объекты расширения принадлежат одной схеме в БД и могут быть
  перемещены в другую.

Makefile/meson.build содержат процедуры, которые указывают, какие компиляторы для каких частей кода использовать, и
куда потом перемещать исполняемые файлы расширения.

Рассмотрим теперь архитектуру расширения, которую можно реализовать при использовании инструментов Rust. Из
@fig:archi видно, что расположение расширения не зависит от положения установленного PostgreSQL. Как и в случае
стандартного расширения, требуется сборочный файл, но поскольку система сборки с GNU Make меняется на Cargo, теперь в
качестве файла, контролирующего компиляцию расширения выступает Cargo.toml. Ручное написание SQL--скриптов не
требуется, поскольку фреймворки Rust предоставляют API, способное с помощью определенных функций генерировать нужные
SQL--скрипты в процессе компиляции и сборки расширения.

#figure(
  image("../images/architecture/arch.png", width: 50%),
  caption: [Архитектура расширения],
) <fig:archi>

Контролирующий файл расширения extension.control по прежнему располагается в директории расширения, при этом во время
его сборки в нужном месте (share/postgresql/extension) создается копия контролирующего расширения файла. Генерируемый
SQL--скрипт перемещается туда же. Сама же библиотека после компиляции копируется из локальной директории сборки в
место, где располагаются все доступные для подключения исполняемые файлы расширений Postgres (lib64/).


== Построение необходимых интерфейсов
Необходимые для работы табличного метода доступа интерфейсы описываются в документации @docs. Согласно ей,
для реализации табличного метода доступа в PostgreSQL требуется реализовать функцию--обработчик для метода доступа,
принимающую фиктивный аргумент псевдотипа internal и возвращающую псевдотип table_am_handler, раскрывающийся при
работе ядра в указатель на структуру типа *TableAmRoutine*. Данная структура определяет исчерпывающий список
функций API метода доступа, которые можно реализовать. Рассмотрим самые важные из них, необходимые для чтения и записи:

- _slot_callbacks_ --- функция, необходимая чтобы конвертировать представление кортежей из слота в то, которое предусматривается методом доступа
- _tuple_insert_ --- функция для вставки кортежа из слота в таблицу с определенными флагами
- _scan_begin_ --- функция для аллоцирования объекта, который используется системой для сканирования таблицы
- _scan_getnextslot_ --- функция, возвращающая следующий кортеж, оформленный как слот
- _scan_end_ --- функция для освобождения памяти и ресурсов, выделенных для чтения таблицы
- _tuple_satisfies_snapshot_ --- проверка на то, что кортеж, содержащийся в слоте, удовлетворяет условиям видимости заданного снимка




== Интеграция и процесс сборки расширения с PostgreSQL
Проводить интеграцию с PostgreSQL планируется с помощью Rust--фреймворка для разработки расширений Postgres pgrx.
Последовательность действий на глобальном уровнеможно описать следующими шагами:

+ Установить PostgreSQL с зависимостями и собрать его
+ Установить сборочную систему Rust
+ Установить pgrx
+ Скомпилировать расширение с помощью pgrx, определив для него место сборки (в случае, если потенциальных версий
  PostgreSQL несколько)
+ Инициализировать кластер данных, подключиться к произвольной БД, включить расширение запросом "CREATE EXTENSION ..."
+ Начать работу с табличным методом доступа

Первый этап можно выполнить с помощью документации Postgres @docs. Согласно ей, перед сборкой (на ОС Linux) необходимо
предварительно установить через пакетный менеджер дистрибутива некоторые зависимости. Самыми важными из них являются
make/meson --- сборочные системы, компилятор языка С, GNU readline для отслеживания истории psql, zlib для сжатия
данных, icu и pkg--config. После их установки и клонирования репозитория на локальную машину, есть два варианта сборки,
в зависимости от того, использует пользователь make или meson. Тем не менее, концептуально они не сильно различаются,
поэтому рассмотрим вариант сборки для meson. Допускается сборка, описанная в документации, но для упрощения
последующего взаимодействия PostgreSQL и pgrx будем собирать Postgres от имени пользователя

#figure(
  ```bash
$ meson setup build --prefix=/path/to/pgdir
$ cd build
$ ninja
$ ninja install
$ mkdir -p /path/to/pgdir/data
  ```,
  caption: [Команды сборки PostgreSQL из исходного кода],
) <lst:pg-compile>

Самым важным здесь является параметр prefix, поскольку в дальнейшем все пути и файлы, с которыми будет работать сервер,
будут распологаться внутри него. Далее, после завершения сборки, необходимо установить сборочную систему для Rust через
установщик rustup. После ее установки должен быть доступен rust toolchain: компилятор языка и сборочная система cargo.

После установки cargo требуется установить pgrx, что можно сделать командой:
#figure(
  ```bash
$ cargo install --locked cargo-pgrx
  ```,
  caption: [Команда установки pgrx],
) <lst:install-pgrx>

После ее выполнения станет доступно написание расширений для PostgreSQL и их компиляция вместе с определенной версией
PostgreSQL. С данного шага пользователь может скомпилировать расширение и интегрировать его в PostgreSQL. Для
разработки расширений pgrx сам инициализирует несколько экземпляров PostgreSQL, но для случая, когда пользователь
желает использовать его, например, с системным PostgreSQL, необходимо поступить следующим образом. При сборке
PostgreSQL в bin каталоге по пути prefix создается исполняемый файл с названием pg_config. Pgrx использует этот файл
как отправную точку для поиска места, куда встраивать объектные файлы, полученные после компиляции расширения. Чтобы
указать сборщику расширения, куда его следует установить после компиляции,
следует выполнить команду:

#figure(
  ```bash
$ cargo pgrx init --pg{$VER}=/path/to/pgdir/bin/pg_config
  ```,
  caption: [Команда задания версии Postgres для сборки pgrx],
) <lst:pgrx-init>


В данном случае значение переменной \$VER должно совпадать с версией Postgres, полученной при исполнении программы pg_config. После этого, для сборки и интеграции расширения с
заданной версией Postgres нужно выполнить команду:

#figure(
  ```bash
$ cargo pgrx install --release --pg-config=/full/path/to/pgdir/bin/pg_config
  ```,
  caption: [Команда запуска сборки и установки расширения],
) <lst:pgrx-release>

С этого момента экземпляр Postgres интегрирован с расширением. Далее все что нужно для начала работы ---
инициализировать кластер по нужному префиксу, запустить сервер СУБД и подключиться через psql или другое клиентское
приложение. В качестве примера можно привести следующие команды:

#figure(
  ```bash
$ /path/to/pgdir/bin/initdb -D /path/to/pgdir/data
$ /path/to/pgdir/bin/pg_ctl -D .../data -l .../data/logfile.log start
$ /path/to/pgdir/bin/createdb test
$ /path/to/pgdir/bin/psql test

  ```,
  caption: [Пример инициализации кластера и подключения к БД],
)


== Выводы
В процессе проектирования был описан общий вид архитектуры разрабатываемого расширения, описаны интерфейсы для его
работы и их назначение. Также были даны пояснения к тому, каким образом расширение будет встроено в сервер PostgreSQL.


#pagebreak()
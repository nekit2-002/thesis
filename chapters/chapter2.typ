#import "../biblio.typ": *
#show bibliography: none
// TODO this import is here only for lsp, need to remove it on release
// #bibl
// -------------------------------------------------------------------------------



= Разработка альтернативного алгоритма реализации MVCC <algo>
Поскольку анализ показал, что механизм undo--логирования (далее сокращенно undo) достаточно
эффективен в решении проблемы нагрузки, создаваемой autovacuum, для разработки нового хранилища было принято решение
использовать его. Данный раздел посвящен подробному рассмотрению принципов undo--логирования и их применению по
отношению к PostgreSQL.

Использование undo--логирования в PostgreSQL можно разделить глобально на две задачи: описание процесса интеграции
undo--журнала с процессами работы с памятью в сервере и разработку формата журнальных записей и принципов их
использования для обеспечения многоверсионности. Данный раздел посвящен решению этих двух задач.



== Встраивание undo--журнала в PostgreSQL
Для того чтобы понять, каким образом использование undo будет интегрировано с PostgreSQL, рассмотрим изменения,
вносимые необходимостью работы с этим журналом в разделяемую память процессов. Из @fig:mem видно, что теперь в
разделяемой памяти помимо буферного кеша, журнала WAL и журнала статусов транзакций (CLOG) появится дополнительное
пространство, отводимое под буфер UNDO. В дальнейшем, аналогично журналу WAL, при конфигурировании системы можно
сделать размер данного буфера настраиваемым за счет своего конфигурационного параметра.


#figure(
  image("../images/undo-desc/newmem.png", width: 50%),
  caption: [Схема содержимого разделяемой памяти],
) <fig:mem>

Как и в случае WAL, с буфером undo работа будет происходить как с кольцевым буфером. На @fig:circular1
показана его начальная конфигурация, в которой стрелками показана очередность вставок данных. Отметим место, с которого
в буфер журнала будет производиться следующая запись как _Место вставки_. Меткой же _Горизонт_ отметим
минимальную позицию (лог), чтение с которой необходимо начать, чтобы было возможно откатить все активные транзакции
и получить полную информацию для всех существующих снимков. По мере окончания транзакций, горизонт будет продвигаться,
стирая логи журнала, которые больше не нужны ни одной транзакции.

#figure(
  image("../images/undo-desc/initial.png", width: 50%),
  caption: [Начальная конфигурация кольцевого буфера],
) <fig:circular1>

Далее, когда вставка достигает конца кольцевого буфера и если горизонт уже сдвинулся (@fig:circular2), тем
самым освободив в место для новой записи, мы начинаем запись логов с начала буфера таким образом, чтобы не перезаписать
данные, которые еще нужны транзакциям и снимкам для работы (то есть мы можем перезаписать все пространство от начала до
отметки горизонта).

#figure(
  image("../images/undo-desc/full.png", width: 50%),
  caption: [Место записи достигло конца буфера, и переходит в начало, освобожденное сдвинувшимся горизонтом],
) <fig:circular2>

Описанную ситуацию (обычно происходящую тогда, когда имеется много коротких транзакций), когда запись журнала
на диск не требуется, можно условно назвать первым режимом работы журнала, при котором все записи и действия происходят
лишь в рамках отведенного под undo журнал куска в разделяемой памяти процессов сервера.

Тем не менее, может возникнуть ситуация (например, если параллельно с одной долго работающей транзакцией работает еще
несколько), когда логов журнала, необходимых для безопасной работы всех текущих транзакций, станет слишком много, и они
переполнят буфер undo. В этом случае следует провести разделение журнала на часть, одна из которых будет храниться в
отведенном месте системы в undo файлах, а вторая останется в кольцевом буфере (см. @fig:circular3). Здесь добавим
еще одну метку _Записано_, отделяющую часть, записанную в файлы от той, что находится в буфере. Такое разделение
журнала между кольцевым буфером и undo файлами можно назвать вторым режимом работы журнала, который подразумевает
запись на диск.

#figure(
  image("../images/undo-desc/split.png", width: 50%),
  caption: [Разделение необходимых логов между файлами и кольцевым буфером],
) <fig:circular3>

Когда длительная транзакция завершается, и горизонт сдвигается сильно вперед, можно освободить данные в файлах, и
вернуться из второго режима работы в режим кольцевого буфера.

#figure(
  image("../images/undo-desc/alloc.png", width: 50%),
  caption: [Определение необходимого для копирования количества данных журнала],
) <fig:files1>


При разделении данных между файлами и кольцевым буфером может возникнуть необходимость скопировать несколько страниц
undo журнала на диск. Чтобы понять как это происходит, рассмотрим @fig:files1. Для определения разницы добавим
метку _Запись в процессе_. Таким образом, все записи журнала в диапазоне [Записно, Запись в процессе) будут
копироваться на диск. Во время копирования чтение из кольцевого буфера разрешено, а запись в него блокируется.

После копирования (см. @fig:files2) метка "Записано" сдвигается, а место в буфере освобождается для вставки, что
дает возможность перейти на первый режим работы журнала undo.

#figure(
  image("../images/undo-desc/copy.png", width: 50%),
  caption: [Конфигурация журнала после копирования страниц в undo--файлы на диске],
) <fig:files2>



== Разработка формата логов журнала undo
Поскольку PostgreSQL осуществляет работу с памятью через страницы, undo--файлы журнала, как и кольцевой буфер, будут делиться на страницы. сами файлы будут располагаться в отдельном
каталоге внутри \$PGDATA. На каждой странице будут находиться undo логи, разбивающиеся, в свою очередь, на заголовок для каждого лога и набор undo--записей. Рассмотрим далее варианты
этих записей.

На настоящий момент предполагается вести два типа undo--записей: для операций _вставки_ и для операций
_обновления_. на @fig:insertrec показан формат журнальной записи для операции INSERT. Заголовок такой записи содержит
информацию о смещении следующей записи, поле для типа записи и информационных флагов, порядковый номер записи и
идентификатор таблицы, в которой производится вставка. В конце записи выделяется пространство для информации о смещении
предыдущей записи.

Между полями заголовка и информации о смещении следующей записи располагается информация о вставке. В качестве
содержимого в ней выступают пары из длин и содержимого полей первичного ключа каждой записи.

#figure(
  image("../images/undo-desc/insert.png", width: 50%),
  caption: [Формат журнальной записи для INSERT операции],
) <fig:insertrec>

На @fig:update представлен общий формат записи для обновления таблицы. Обновление можно разделить на три случая: в
строке обновляются поля, которые не входят в первичный ключ, происходит удаление строки, или происходит обновление
первичного ключа строки и, возможно, некоторых неключевых полей. Несмотря на разное содержимое отдельных полей, формат
записи, представленный на @fig:update, подходит для всех трех случаев.

Часть заголовка записи, содержащая смещение следующей записи, тип операции с флагами, порядковый номер записи и
идентификатор таблицы остается той же. Дополнительно к этой информации в заголовок теперь входят данные об
идентификаторе транзакции, которая породила историческую версию строки (или отдельных полей), сохраняемой в записи, и
указатель на запись с версией строки, которая существовала еще раньше (то есть предыдущую версию до сохраняемой). В
конце записи по--прежнему находится смещение предыдущей записи.

Основная информация записи всегда содержит поля первичного ключа (как и в случае с INSERT) и количество обновляемых
полей. Это количество может различаться в зависимости от типа обновления. Например, если был обновлен не первичный
ключ, в undo--запись будут сохраняться лишь те поля, которые были обновлены, а не вся строка полностью. При этом
информация о каждом поле будет содержать его номер, длину и историческую версию содержимого поля. В случае операции
удаления строки в запись входит информация о строке полностью и сама строка помечается как удаленная.
В случае, когда был обновлен первичный ключ, будет происходить две записи: одна из них формата обновления, помечающая
предыдущую строку как удаленную и содержащая все ее поля, а вторая формата вставки, совершающая вставку новой строки в
таблицу.

#figure(
  image("../images/undo-desc/upd.png", width: 50%),
  caption: [Формат журнальной записи для UPDATE операции],
) <fig:update>

Рассмотрим далее структуру undo--лога, объединяющего последовательные логически связанные записи, порождаемые одной
транзакцией. Из рисунка @fig:log видно, что такой лог состоит из двух частей: заголовок лога и набор undo--записей,
каждая из которых описана в формате, представленном выше. Заголовок лога содержит информацию о транзакции, породившей
этот лог, номер коммита (дополнительный монотонно возрастающий идентификатор, который предполагается ввести для
отслеживания момента фиксирования пишущей транзакции), маркер того, что в логе есть запись, содержащая пометки
строк как удаленные, смещение до конца заголовка лога (и начала первой записи в нем соответственно) и смещения до
предыдущего и следующего лога.

#figure(
  image("../images/undo-desc/log.png", width: 50%),
  caption: [Формат лога для связки последовательных undo--записей],
) <fig:log>

Используя такие форматы записей и логов, можно реализовать поддержку MVCC за счет них. Пусть мы имеем для каждой строки
в таблице идентификатор транзакции, которая последней вставляла или обновляла строку и указатель на запись в
undo--логе, которая содержит предыдущую версию строки, если таковая имеется. Когда транзакция делает снимок, она на
основе правил видимости определит, должна ли строка быть видна снимку или нет. Если строка не должна быть видима, будет
происходить восстановление за счет перехода по указателю на предыдущую версию в undo--логе. Правила определения
видимости такие же, как и те, что описаны в разделе @snaps, но теперь снимок будет содержать еще одно поле,
которое описывается ниже.

Как и в случае со стандартным хранилищем, при определенных условиях в undo--логах начнут скапливаться данные о
предыдущих версиях строк, а также в самих хранилищах будут появляться строки, которые помечены как удаленные, поэтому
потребуется некоторый асинхронный процесс очистки (в других СУБД с похожими идеями этот процесс обычно называется
purge process). Тем не менее, между ним и autovacuum есть несколько существенных различий. Autovacuum не производит
физической очистки, что означает, что строки будут лишь помечаться как неиспользуемые в интервалы его работы. При
использовании же undo--логов строки будут помечаться как неиспользуемые сразу по завершении записи, а с приходом
purge--процесса будет происходить физическая очистка таблицы и журнала undo. Когда читающая транзакция делает снимок, в
него записывается максимальный номер коммита. Тогда, если номер коммита некоторой транзакции строго меньше, чем все
максимальные номера коммитов, записанные в текущих снимках читающих транзакций, то это значит, что транзакция была
зафиксирована раньше, чем началось любое чтение, и значит все чтения видят уже новую версию строки, поэтому не будет
нужды строить предыдущие версии из логов этой транзакции и старше, и их можно очистить, совместно со всеми старыми
версиями строк.

== Выводы
В ходе проведения теоретической работы был разработан принцип использования журнала undo совместно с механизмом работы
PostgreSQL с памятью устройства, на котором запущен сервер, и многоверсионности. Также был описан формат журнальных
записей undo и организация использования файлов системы.




#pagebreak()
